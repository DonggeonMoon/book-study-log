# 7장 캐시

웹 캐시: 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치

## 불필요한 데이터 전송

- 여러 클라이언트가 자주 쓰인는 서버에 페이지 접근 시, 모두 한 번씩 전송(불필요함)
- 단점
    - 네트워크 대역폭 소모
    - 전송 속도 감소
    - 웹 서버 부하 가중
- 캐시를 사용하면 캐시된 사본을 뒤이은 응답으로 사용하여 트래픽 낭비 감소

## 대역폭 병목

- 많은 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭 제공
- 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 캐싱은 성능을 대폭 개선 가능

## 갑작스런 요청 쇄도

- 캐시는 갑작스런 요청 쇄도에 대처하기 위해 중요함

## 거리로 인한 지연

- 거리가 멀면 트래픽이 지연됨(라우터 지연, 빛의 속도 그 자체의 지연 등)
- 가까운 곳에 캐시를 설치하면 전송되는 거리를 줄일 수 있음

## 적중과 부적중

캐시 적중(cache hit): 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 있는 경우(요청 처리 가능)
캐시 부적중(cache miss): 캐시에 요청이 도착했을 때, 그에 대응하는 사본이 없는 경우(요청이 원서버로 전달)

- 재검사: 신선도 검사(사본의 최신 여부 확인)
    - 캐시는 원하면 언제든지 사본 재검사 가능, but 대역폭 부족으로 요청 시, 필요시에만 재검사
    - 원서버로 재검사 요청 보내서 컨텐츠 변경 안 됐다면 304 Not Modified, 기존 사본 응답(재검사 흑은 느린 적중)
    - 많이 쓰이는 도구 If-Modified-Since 헤더
    - GET If-Modified-Since 요청 서버 도착 시 세 가지 상황
        - 재검사 적중: 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 작은 304 Not Modified 응답을 보냄
        - 재검사 부적중: 서버 객체가 캐시된 사본과 다르다면, 서버는 컨텐츠 전체와 함께 평범한 200 OK 응답을 전송
        - 객체 삭제: 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 반환, 캐시는 사본 삭제
- 적중률(캐시 적중비, 문서 적중률, 문서 적중비): 캐시가 요청을 처리하는 비율(0 ~ 100%)
    - 적중률이 높을수록 좋음(오늘날 40%면 괜찮음)
- 바이트 적중률: 캐시를 통해 제공된 모든 바이트의 비율 표현
    - 문서들이 모두 같은 크기인 건 아니기 때문에(크기가 더 클수록 전체 트래픽에 더 크게 기여) 문서 적중률 보다 바이트 적중률을 더 선호
- 적중과 부적중의 구별
    - 불행히도, HTTP는 클라이언트에 응답이 캐시 적중이었는지 아니면 부적중인지 말해줄 수 있는 방법 부제공
        - 몇몇 프록시 캐시는 Via 헤더에 추가 정보 첨부
        - 응답 Data 헤더 이용(응답 생성일이 더 오래됐다면 캐시된 응답)
        - Age 헤더 이용

## 캐시 토폴로지

- 개인 전용 캐시: 한 명에게만 할당된 캐시
    - 작고 저렴
    - 웹 브라우저는 개인 전용 캐시 내장
- 공용 프록시 캐시(프록시 캐시): 공유된 캐시
    - 로컬 캐시에서 문서를 제공하거나 사용자 입장에서 접근
    - 불필요한 트래픽을 더 많이 줄일 수 있음
    - 프록시 캐시는 6장의 프록시를 위한 규칙을 따름(프록시 설정 방법 등)
- 프록시 캐시 계층들
    - 작은 캐시에서 부적중 발생시 더 큰 부모 캐시가 걸러 남겨진 트래픽 처리하도록 하는 계층이 합리적인 경우가 더 많음
    - 클라이언트 주위에는 작고 저렴한 캐시를, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시 사용
- 캐시망, 콘텐츠 라우팅, 피어링
    - 몇몇 네트워크 아키텍처는 복잡한 캐시망을 만들고 캐시 커뮤니케이션 결정을 동적으로 내림
    - 인터넷 트랜짓(네트워크간 이동) 금지, 형제 캐시는 부지원

## 캐시 처리 단계

1. 요청 받기
2. 파싱 - URL, 헤더 추출하여 조작하기 쉬운 자료구조에 담기
3. 검색 - 로컬 복사본 유무 검사, 없으면 사본 가져오기
4. 신선도 검사
5. 응답 생성
6. 발송
7. 로깅 - (선택사항) 캐시가 로그 파일에 트랜잭션에 대해 서술한 로그 남김

## 사본을 신선하게 유지하기

HTTP는 문서 만료, 서버 재검사를 통해 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해줌

- 문서 만료
    - Cache-Control:max-age, Expires 헤더 이용해서 유효기간 기록
    - 캐시 문서가 만료되기 전에 서버 접촉 없이 사본 제공 가능(캐시 리소스 거부 요청 아닐 경우)
    - but, 캐시 문서 만료 시 반드시 변경된 것이 있는지 검사 후 있으면 신선한 사본, 새 유효기간 얻어와야 함
- 유효기간과 나이
    - HTTP/1.0+ Expires, HTTP/1.1 Cache-Control:max-age는 컴퓨터 시간이 올바를 것을 요구
- 서버 재검사
    - 캐시된 문서가 '만료'되었다는 것은 문서가 원 서버와 다르다는 게 아니라 재검사할 때라는 것
    - 재검사 결과 컨텐츠 변경 시 새로운 사본을 가져와 저장 후 클라이언트 전송함
    - 불변경 시 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신함
- 조건부 메서드와 재검사
    - HTTP는 '조건부 GET'이라는 요청을 보낼 수 있게 해줌
    - If-Modified-Since: <date>, If-Modified-Match: <tags>와 같은 조건부 해더를 추가
- If-Modified-Since: 날짜 재검사
    - IMS 요청. 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 함
    - 해당 날짜 이후 변경 시 성공
    - 해당 날짜 이후 불변경 시 304 Not Modified 응답 반환
    - Last-Modified 헤더(최근 변경 일시)와 함께 동작
- If-None-Match: 엔티티 태그(ETag) 재검사
    - 엔티티 태그가 변경되었을 때 사용 가능
    - 여러 개의 사본 갖고 있는 경우 여러 개의 엔티티 태그 포함 가능 (쉼표로 구분)
- 약한 검사기, 강한 검사기
    - HTTP/1.1 지원하는, 비록 컨텐츠가 조금 변경되었어도 그 정도면 같은 것이라고 서버가 주장할 수 있도록 해주는 약한 검사기
    - 컨텐츠가 바뀔 때마다 바뀌는 강한 검사기
    - 약한 검사기를 구분하기 위해 'W/' 접두사로 약한 검사기 구분
- 엔티티 태그(ETag)와 Last-Modified 일시 사용 시기
    - 서버가 엔티티 태그를 반환했다면 반드시 엔티티 태그 검사기를 사용해야 함
    - 서버가 Last-Modified 값만 반환했다면, 클라이언트는 If-Modified-Since 검사 사용 가능
    - 둘 다 사용 가능하다면 클라이언트는 각각을 위해 두 가지의 재검사 정책을 사용해야 함
    - HTTP/1.1 원 서버는 가능하다면 엔티티 태그 검사기를 보내야 하며, 이점이 있다면 약한 엔터티 태그를 보낼 수 있음
    - Last-Modified 값을 같이 보내는 것도 선호됨
    - HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔터티 태그 조건부 헤더를
      모두 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 304 Not Modified 응답을 반환해서는 안 됨

## 캐시 제어

문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인가

- no-store: 캐시가 응답의 사본을 만드는 것을 금지
    - 캐시는 응답 전달 후 객체 삭제
- no-cache: 로컬 캐시 저장소에 저장될 수 있지만 서버와의 재검사 없이는 클라이언트 불제공
    - cf) pragma: nocache 헤더는 HTTP/1.0+와의 호환성 위해 1.1에 포함됨
- Max-Age 응답 헤더: 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른시간
    - max-age를 0으로 설정하면 매 접근마다 문서를 캐시하지 않거나 매 접근마다 리프레시 하도록 요청할 수 있음(캐시 불사용)
- Expires 응답 헤더(deprecated): 초 단위 시간 대신 실제 만료 일시를 명시함
- Must-Revalidate 응답 헤더: 캐시가 이 객체의 신선하지 않은 사본을 원 서버와 최초의 재검사 없이는 제공해서는 안 됨을 의미
    - 만료 정보를 엄격히 따르도록 함
    - must-revalidate 신선도 검사시 원 서버 사용할 수 없는 경우 504 Gateway Timeout error 반환해야 함
- 휴리스틱 만료
    - max-age나 expires 헤더 둘 다 없으면 경험적인(heuristics) 방법으로 최대 나이 계산
    - 휴리스틱 만료 알고리즘
        - LM 인자 알고리즘
        - 캐시된 문서의 마지막 변경일이 상당히 지났다면 안정적인 문서로 보고 더 오래 보관
        - 최근에 변경되었다면 자주 변경될 것으로보고 서버 재검사 전 짧은 기간 동안만 캐시
- 클라이언트 신선도 제약
    - 강제 리프레시(리로드) 버튼은 Cache-control 요청 헤더가 추가된 GET 요청을 강제로 발생시켜 서버로부터 컨텐츠를 무조건 가져음
    - 신선도 요구사항을 느슨하게 하거나 제약을 엄격하게 하기
        - Cache-control: max-stale <s> - <s> 없으면 신선하지 않은 문서도 제공 가능, 있으면 만료시간이 <s>만큼 지난 문서까지 가능
        - Cache-control: min-fresh <s> - 클라이언트는 <s> 초까지 신선한 문서만 받아들임
        - Cache-control: max-age <s> - <s> 초보다 오래된 캐시된 문서를 반환하지 않음
        - Cache-control: no-cache 또는 Pragma: no-cache - 캐시된 리소스는 재검사하기 전까지는 받아들이지 않음
        - Cache-control: no-store - 문서의 흔적을 최대한 빨리 삭제할 것을 원함(민감한 정보가 포함돼 있는 경우 등)
        - Cache-control: only-if-cached - 캐시에 들어있는 캐시만 원함
- 주의사항
    - 문서 만료는 완벽하지 않음
    - 퍼블리셔가 유효기간을 까마득한 미래로 설정하거나 아예 사용하지 않는 경우도 있기 때문

## 캐시 제어 설정

- 아파치로 HTTP 헤더 제어
    - 필요한 아파치 확장 모듈
        - mod_headers: 개별 헤더 설정 모듈
        - mod_expires: 적절한 만료 날짜가 담긴 expires 헤더를 자동 생성해주는 모듈
        - mod_cern_meta: 헤더들의 파일을 특정 객체와 연결해주는 모듈
- HTTP-EQUIV를 통한 HTML 캐시 제어
    - HTML 2.0은 <META HTTP-EQUIV> 태그를 정의하여 웹서버 설정 파일과 상호작용 없이도 헤더 정보 추가 가능
    - 문서 최상단에 위치하여 문서와 연동돼야 하는 헤더들을 정의함
    - 불행히도 이 기능을 지원하는 웹서버나 프록시는 거의 없음(서버 부하 가중, 설정값이 정적임, HTML 이외에 다른 파일에서는 지원 안 함)
    - 다만, 몇몇 브라우저는 이들을 파싱하여 실제 헤더처럼 다룸
    - 일반적으로, 이 방법은 캐시를 제어하는 데 좋지 못한 방법이고, 올바르게 설정된 서버가 보내온 헤더를 이용하는 것이 바람직함

## 자세한 알고리즘

- 나이와 신선도 수명
    - 캐시된 사본의 나이가 신선도 수명보다 작으면 그 사본은 충분히 신선함
    - 나이: 서버가 문서를 보낸(혹은 마지막 재검사 후) 그 문서가 나이를 먹은 시간의 총합
        - Age 헤더를 사용하거나 Date 헤더로 계산하여 판별
    - 신선도 수명: 아직 문서가 신선하다고 볼 수 있는 수명
        - 약간 신선하지 않은 문서라도 받아들이기도 함(max-stale 헤더 사용)
        - 조만간 신선하게 되지 않은 문서조차 받아들이지 않기도함(min-fresh)
- 나이 계산: 캐시는 캐시 사본의 나이를 쉽게 알 수 있지만, 캐시에서 온 응답의 나이를 알아내기는 어려움(시계 시간 차이, 어디서 왔는지 모름)
    - 겉보기 나이는 Date 헤더에 기반
        - 모든 컴퓨터의 시간이 같다고 가정 -> 현재 시간 - 문서를 보낸 시간
        - but, 시간 차이가 극단적인 경우(클록 스큐 문제)도 있기 때문에 대비 필요
        - 문서가 우리의 캐시에 도착 했을 때의 나이 = 겉보기 나이 = max(0, 응답을 받은 시각 - Date 헤더 값)
    - 점층적 나이 계산
        - 위 산식으로 음수 나이는 제거 가능하지만, 클록 스큐로 인한 정확도 손실 전반에 대해서 어쩔 수 없음
        - 우회책: 문서가 프록시, 캐시 통과 시마다 Age 헤더에 상대적인 나이를 누적하도록 함
        - but, 비-HTTP/1.1 장치는 Age 헤더를 인식하지 못하고 헤더를 고치지 않거나 삭제함 -> Age 헤더는 항상 상대 나이에 모자란 추정 값
        - 상대 나이 값, Date 기반 나이 중 보수적인(가장 큰) 값 선택됨
        - 문서가 우리의 캐시에 도착 했을 때의 나이 = 보정된 겉보기 나이 = max(겉보기 나이, Age 헤더 값)
    - 네트워크 지연에 대한 보상
        - 느린 네트워크나 서버 과부하로 인해 트래픽은 느려질 수 있음 -> 상대 나이 계산은 문서 나이에 대한 상당히 모자란 추정이 될 수 있음
        - 왕복 지연을 측정하는 것은 상대로 쉬움 -> HTTP/1.1은 이를 이용해 계산한 전체 왕복 시간을 더함으로써 네트워크 지연을 보수적으로 교정
        - 문서가 우리의 캐시에 도착 했을 때의 나이 = 보정된 겉보기 나이 + 응답 지연 추정값(응답을 받은 시각 - 요청을 보낸 시각)
    - 완전한 나이 계산 알고리즘
        - 응답이 캐시에 한번 저장되면 나이를 더 먹게 됨
        - 문서의 현재 나이를 계산하기 위해 그 문서가 캐시에 얼마나 오랫동안 머물렀는지 알 필요가 있음
        - 나이 = 문서가 우리의 캐시에 도착 했을 때의 나이 + 사본이 얼마나 오래 우리 캐시에 있었는지
    - 신선도 수명 계산
        - 신선도 수명은 문서가 특정 클라이언트에게 제공해주기에는 더 이상 신선하게 될 때까지 얼마나 오랜 시간 동안 가져올 수 있도록 허용되는지 말해줌
        - 신선도 수명은 서버와 클라이언트의 제약조건에 의존함

## 캐시와 광고

캐시는 사용자를 도와 더 좋은 경험을 제공하고, 네트워크 사용자들이 트래픽 줄일수 있게 해줌

- 광고 회사 딜레마
    - 컨텐츠 제공자들은 광고를 통해 돈을 버는데, 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있음
    - 만약 캐싱이 완벽하게 동작한다면, 캐시가 접근을 모두 흡수하여 원 서버는 HTTP 접근을 전혀 수신하지 않게 됨
- 퍼블리셔의 응답
    - 광고 회사들은 캐시가 광고 시청수를 가로채지 못하도록 모든 종류의 캐시 무력화 기법을 사용함
    - 불행히도, 광고 시청 수를 높게 유지하려는 시도는 컨텐츠 제공자가 그들의 사이트에 대한 캐싱의 긍정적인 효과를 감소 시킴
    - 이상적으로는 캐시가 적중 수를 컨텐츠 제공자에게 알려주어야 함
        - 한 가지 방법은 모든 접근에 대해 원 서버와 재검사하도록 캐시를 설정하는 것
        - 이는 원 서버에 캐시 적중이 있었음을 알리지만 본문 데이터를 전송하지 않음
        - but, 트랜잭션을 느리게 만듦
- 로그 마이그레이션
    - 캐시가 모든 적중 로그를 유지하고 그 로그를 서버에게 나누어주는 방법이 이상적임
    - 몇몇 큰 캐시 제공자들은 직접 컨텐츠 제공자들에게 캐시 로그를 수동으로 처리해서 직접 건네줌
    - but, 적중 로그 크기 때문에 옮기기 어렵고 표준화도 되어 있지 않음
- 적중 측정과 사용량 제한
    - RFC 2227이 더 간단한 방법 정의함
    - HTTP에 때때로 특정 URL에 대한 캐시 적중 횟수를 정기적으로 서버에게 돌려주는 Meter 헤더를 추가함
    - 서버가 캐시된 문서가 적중한 횟수의 정기적인 업데이트를 캐시로부터 받음
    - 서버는 캐시가 서버에게 보고해야 하기 전까지 문서를 제공할 수 있는 회숫나 처리 시간을 제어 가능(사용량 제한)
    - 캐시가 원 서버에 보고하기 전까지 캐시된 리소스가 사용될 수 있는지 서버가 제어할 수 있게 해줌