# 6장 프록시

웹 프록시 서버 -> 중개자

## 웹 중개자

프록시 서버는 웹 서버이면서 웹 클라이언트임

- 공유 프록시: 여러 클라이언트가 함께 사용하는 프록시
- 개인 프록시: 하나의 클라이언트만을 위한 프록시
- 프락시 vs 게이트 웨이
    - 프록시: `같은 프로토콜`을 사용하는 둘 이상의 애플리케이션을 연결
    - 게이트웨이: 클라이언트와 서버가 서로 `다른 프로토콜`로 말핟더라도 서로 간의 트랜잭션을 완료할 수 있는 프로토콜 변환기

## 사용 이유

- 어린이 필터(필터링 프록시): 부적절한 사이트 접근 거부
- 문서 접근 제어자: 접근 제어 전략 구현, 감사 추적용
- 보안 방화벽: 보안 강화, 한 지멈에서 출입 통제, 트래픽 조사용 후크(hook) 제공
- 웹 캐시: 인기 있는 문서 사본 관리하고 빠르게 제공하여 통신 효율화
- 대리 프록시(리버스 프록시): 웹 서버인 척하여 요청을 받고 컨텐츠 위치를 찾기 위해 다른 서버와 통신(+ 느린 웹 서버 성능 개선용 -> 서버 가속기)
- 컨텐츠 라우터: 트래픽 조건 및 컨텐츠 종류에 따라 특정 웹 서버로 유도
- 트랜스 코더: 컨텐츠를 클라이언트에게 전달하기 전 본문 포맷 수정(트랜스코딩)
- 익명화 프록시(Anonymizer): HTTP 메시지에서 신원을 식별할 수 있는 특성들(IP 주소, From 헤더 등)을 적극 제거하여 개인 정보 보호 및 익명성 보장

## 프록시 위치

- 출구 프록시: 로컬 네트워크 출구(트래픽 제어용, 방화벽 제공용, 요금 절약 및 트래픽 성능 개선용, 필터링용)
- 접근(입구) 프록시: ISP 접근 지점
- 대리 프록시(리버스 포록시): 웹 서버들 바로 앞에 위치.(요청 처리 및 자원 요청, 보안 기능, 캐시) 모든 요청은 이 프록시로 가게 됨.
- 네트워크 교환 프록시: 네트웤 사이 인터넷 피어링 교환 지점(혼잡 완화, 트래픽 흐름 감시용)
- 프록시 계층
    - 여러 프록시들이 연쇄를 구성(서버에 가까운 쪽이 다음 프록시의 부모)
- 프록시 계층 컨텐츠 라우팅
    - 프록시 계층은 정적이 아니라 동적으로 만들 수도 있음
    - 동적 부모 선택
        - 부하 균형: 부하 분산 위해 부모 작업량 수준에 근거하여 선택
        - 지리적 인접성에 근거한 라우팅: 원 서버의 지역을 담당하는 부모 선택
        - 프로토콜/타입 라우팅: URI에 근거하여 다른 부모나 원 서버로 라우팅
        - 유료 서비스 가입자를 위한 라우팅: 빠른 서비스 가입 시 성능 개선을 위한 압축 앤진으로 라우팅
    - 트래픽 처리 방법
        - 클라이언트 수정: 크롬, 익스플로러 등 브라우저에 자동 프록시 설정
        - 네트워크 수정(인터셉트 프록시): 트래픽을 지켜보고 가로채어 클라이언트 모르게 프록시로 보냄(스위치, 라우터 필요)
        - DNS 이름공간 수정(대리 프록시): 대리 프록시가 웹 서버의 이름과 IP 주소를 자신이 직접 사용(DNS 설정)
        - 웹 서버 수정: 웹 서버가 리다이렉션 명령을 돌려줘서 요청을 프락시로 리다이렉트

## 클라이언트 프록시 설정

- 수동 설정: 브라우저에 명시적으로 프록시 설정
- 브라우저 기본 설정: 브라우저 벤더나 배포자가 기본적으로 프록시를 미리 설정
- 프록시 자동 설정(PAC): 자바스크립트로 된 프락시 자동 설정(PAC) 파일을 가져올 수 있는 URI를 제공하고 그 PAC 파일을 실행
    - PAC 파일은 반드시 FindProxyForUrl(url,host)을 정의해야 함
    - 반환값은 DIRECT (직접 연결), PROXY host:port (지정한 프록시 사용), SOCKS host:port (지정한 SOCKS 서버 사용) 중 하나
- WPAD(Web Proxy Auto-Discovery Protocol) 발견: 브라우저가 자동 설정 파일을 다운 받을 수 있는 '설정 서버'를 자동으로 찾아주는 WPAD 프로토콜을 제공
    - WPAD를 사용하여 PAC URI를 찾고 PAC 파일을 가져와 실행한 후 프락시 서버를 알아내 요청을 처리함
    - 올바른 PAC 파일을 알아내기 위해 여러 발견 기법을 사용 (DHCP, SLP 등)

## 프록시 요청의 미묘한 특징들

- 프록시 URI와 서버 URI은 다름
    - 프록시 URI는 전체 URI, 서버는 부분 URI 사용
        - 프록시와 가상 호스팅이 존재하지 않던 시절에 만들어졌기 때문
        - 클라이언트에서 명시적으로 프록시 설정할 경우 알아서 전체 URI 보내줌(사용 안 하면 그대로 부분 URI)
- 가상 호스팅에서 일어나는 같은 문제
    - 가상으로 호스팅 되는 웹 서버는 Host(호스트와 포트 정보 담겨 있음) 헤더 요구
- 인터셉트 프록시는 부분 URI 받음
    - 대리 프록시나 인터셉트 프록시(트래픽을 가로채 캐시된 응답을 돌려주는 등의 일을 함)는 부분 URL을 받을 것임(클라이언트는 대화 상대가 프록시임을 모르므로)
- 프록시 프락시 요청과 서버 요청을 모두 다룰 수 있음
    - 프록시 URI 규칙
        - 완전한 URI 주어지면 그것을 사용
        - 부분 URI, Host 헤더가 있으면 Host를 이용해 원 서버의 이름과 포트 번호를 알아냄
        - Host 헤더 없이 부분 URI만 있으면, 프록시 원 서버를 알아내야 함
            - 대리 프록시는 프록시에 실제 서버 주소와 포트번호가 설정되어 있을 수 있음
            - 이전에 트래픽을 받았던 인터셉터라면, 그 트래픽의 IP 주소와 포트 번호 사용 가능(프록시가 그것을 사용하도록 설정해놨을 경우)
            - 이전에 어떤 인터셉트 프록시가 가로챘던 트래픽을 받았고, 그 인터셉트 프록시가 원 IP 주소와 포트 번호를 사용할 수 있도록 해뒀다면 그것을 사용
            - 모두 실패 했다면, 정보 부족이므로 에러 메시지를 반환해야 함
- 전송 중 URI 변경
    - URI 변경은 주의 필요(사소한 변경도 상호 운용성 문제 발생 가능성)
    - 가능한 관대하도록 애써야 함(프로토콜 준수를 너무 강요하지 말 것)
    - HTTP 명세에서는 인터셉트 프록시가 절대 경로를 아예 못 고치게 함(빈 경로를 '/'로 바꾸는 것 제외)
- URI 클라이언트 자동확장과 호스트명 분석
    - 브라우저는 프록시가 없으면 사용자 입력 URI로 IP 주소를 탐색
    - 호스트명을 못 찾으면, 자동적으로 호스트명의 '확장'을 제공하고 다음과 같이 몇 가지 시도를 함
        - 웹사이트 이름의 가운데 부분만 입력 시, 'www.' 접두사를 붙이고 '.com' 접미사를 붙임
        - 몇몇 브라우저는 해석할 수 없는 URI를 서드 파티 사이트로 넘겨서 오타 교정 시도 및 의도한 URI를 제시함
        - 대부분의 시스템에서 DNS는 사용자가 호스트명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정됨
            - ex) oreilly.com 도메인에서 host7 입력 시, host7.oreilly.com을 찾아봄
- 프록시 없는 URI 분석(URI Resolution)
    - oreilly를 브라우저 URI 창에 입력하면 DNS에 질의하고 실패함
    - 브라우저는 'www.oreilly.com'으로 자동 확장하여 DNS에 다시 질의함
    - 'www.oreilly.com'을 찾고 IP 주소를 돌려줌
    - 이후 HTTP 통신 과정(생략)
- 명시적인 프록시를 사용할때의 URI 분석
    - 명시적인 프록시에서는 위와 같은 확장을 사용할 수 없음(브라우저의 URI가 프록시를 그냥 지나쳐 버림)
    - 몇몇 프록시는 브라우 저 자동 확장이나 접미사 추가 등을 흉내내려고 시도하기도 함
- 인터셉트 프록시를 이용한 URI 분석
    - 인터셉트 프록시의 동작은 자동확장 가능한 브라우저와 커넥션 맺기 이후로 차이가 발생함
    - 클라이언트는 발견한 모든 IP 주소에 대해 접속을 시도하지만, 프록시 서버의 접속 시도는 실패 시 프록시 서버에 의해 종료됨
    - 프록시가 최종적으로 진짜 원 서버와 상호작용할 준비가 되었을 대 프록시가 실제로 다운된 서버를 가리키고 있음을 알 게 될 것임
    - 브라우저와 동등한 장애 허용을 제공하기 위해서, 프록시는 호스명을 다시 분석하든 IP 주소에 대한 역방향 DNS 룩업을 해서든 다른 IP를 시도해야 함

## 메시지 추적

많은 회사들이 보안과 비용 절감을 위해 캐시 프록시 서버를 사용함
많은 대형 ISP들이 성능개선과 기능 구현을 위해 프록시 캐시를 사용함
프록시가 흔해지면서 프록시를 넘나드는 메시지 흐름을 추적하고 문제점 찾아내는 것이 필요해짐

- Via 헤더
    - 메시지가 지나는 각 중간 노드 정보 나열
    - 메시지가 또 다른 노드를 지날 때 마다 노드가 추가되어야 함
    - 메시지 전달을 추적, 메시지 루프 진단, 발송자들의 프로토콜 다루는 능력 조사, 네트워크 라우팅 루프 탐지
    - 프록시는 요청 보내기전 자신을 가리키는 유일한 문자열을 삽입해야 하고 네트워크에 라우팅 루트 있는지 탐지 위해 이 문자열이 요청에 있는지 검사해야함
    - 문법
        - 쉼표로 경유지(waypoint) 구분
        - Via는 waypoint 포함하고, waypoint는 received-protocol, received-by 포함(상세 문법은 생략)
        - 프로토콜 이름: 중개자가 받은 프로토콜(HTTP는 생략 가능)
        - 프로토콜 버전: 수신한 메시지의 버전
        - 노드 이름: 중개자의 호스트와 포트 번호
        - 노드 코멘트: 중개자 노드를 서술하는 선택적인 코멘트
    - Via 요청과 경로
        - 요청 메시지와 응답 메시지는 모두 Via 헤더를 가지며, 두 헤더는 서로 언제나 거의 반대임
    - Via와 게이트웨이
        - Via 헤더는 프로토콜 변환을 기록하므로 프로토콜 능력과 변환이 있었는지 알아챌 수 있음
    - Server 헤더와 Via 헤더
        - Server 응답 헤더 필드는 원 서버에 의해 사용되는 소프트웨어를 알려줌
        - Server 헤더는 원 서버를 위해 존재하므로 프록시가 수정해서는 안 됨
    - Via가 개인정보 보호와 보안에 미치는 영향
        - 프록시가 네트워크 방화벽의 일부인 경우 등 Via 헤더에 정확한 호스트 명이 들어가면 안 되는 경우가 있음
        - 이 경우 호스트명을 적당한 가명으로 교체해야 함
        - 내부 네트워크 아키텍처 설계와 토폴로지를 알아내기 어렵게 하기 위해 Via 경유지 항목들을 하나로 합칠 수 있음
            - 여러 경유지들이 모두 같은 조직 통제 하에 있고 호스트가 이미 가명으로 교체된 경우에만 가능
    - TRACE 메서드
        - 프록시 네트워크를 통해 홉에서 홉으로 전달될 때마다 메시지 내용이 어떻게 변하는지 편리하게 관찰할 방법이 필요
        - HTTP/1.1의 TRACE 메서드는 요청 메시지의 경유지와 수정 과정을 관찰/추적할 수 있게 해줌(프록시 흐름 디버깅하는 데 매우 유용)
        - TRACE 요청이 목적지 서버에 도착 했을 때 서버는 전체 요청 메시지를 HTTP 응답 메시지 본문 에 포함히켜 송신자에게 그대로 돌려 보냄
        - 클라이언트는 서버가 받은 메시지와 그 메시지가 지나간 프록시 목록 검사 가능
        - Max-Forwards: TRACE, OPTIONS 요청의 프록시 홉 개수를 제한하기 위해 사용(무한 루프 등 체크용)

## 프록시 인증

프록시 인증: 사용자가 유효한 접근 권한 자격을 프록시에 제출하지 않는 한 컨텐츠에 대한 요청을 차단(접근 제어 기능)

- 메커니즘
    - 제한된 컨텐츠에 대한 요청이 프록시 서버에 도착했을 때 응답
        - 407 Proxy Authorization Required 상태 코드
        - 자격 제출 방법을 설명하는 Proxy-Authenticate 헤더 필드를 반환
    - 407 응답을 받은 클라이언트는 요구되는 자격을 수집, 획득하고 Proxy-Authorization 헤더 필드에 담아서 요청을 다시 보냄
    - 자격이 유효하면 프록시는 원 요청을 연쇄를 따라 통과시키고, 아니라면 407 응답을 보냄
- 프록시 인증은 프록시가 연쇄상에 여러 개 있으면 일반적으로 잘 동작하지 않음

## 프록시 상호운용성

클라이언트, 서버 프록시는 여러 벤더가 만들다보니 서로 다른 여러 기능을 제공하기도하고 다양한 버그를 갖고 있음

- 지원하지 않는 헤더와 메서드 다루기
    - 프록시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 함
    - 같은 이름의 헤더 필드가 여러 개 있는 경우 그 상대적 순서도 반드시 유지해야 함
    - 모르는 메서드는 가능한 그 메시지를 다음 홉으로 전달하려고 시도해야 함
- OPTIONS: 어떤 기능을 지원하는지 알아보기
    - OPTIONS 메서드는 서버나 웹 서버의 특정 리소스가 어떤 기능을 지원하는지 클라이언트가 알아볼 수 있게 해줌
    - 서버 전체 능력에 대해 물으려면 다음과 같이 사용함
    - ex) OPTIONS * HTTP/1.1
    - 실제 리소스에게 가능한 기능들을 물으려면
    - ex) OPTIONS <리소스 URI> HTTP/1.1
- Allow 헤더
    - 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거함
    - 새 리소스가 지원했으면 하는 메서드를 추천하기 위한 요청 헤더로도 사용 가능(지원 의무 없음)
        - 응답은 실제로 지원하는 메서드들을 열거
