# 8장 통합점: 게이트웨이, 터널, 릴레이

- HTTP 앱은 인터넷 상의 컨텐츠(정적인 문서부터 동적인 페이지까지)에 접근하는 통일된 방법을 제공함
- HTTP 위에 다른 프로토콜을 얹을 수도 있음
    - HTTP만 허용하는 방화벽이 있는 회사에서 다른 프로토콜로 통신하는 트래픽을 HTTP로 감싸서 터널링/릴레이
- HTTP는 웹에 있는 모든 리소스에 대한 프로토콜로 사용됐고 앱 간 서로 다른 프로토콜 상호 운용 용도로 사용하기도 함

## 게이트웨이

서로 다른 프로토콜과 애플리케이션 간의 HTTP 인터페이스
리소스를 받기 위한 경로를 안내하는 역할(하나의 게이트웨이에 여러 앱 연결)
게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여 HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 해줌

- 클라이언트 측 게이트웨이와 서버 측 게이트웨이
    - 게이트웨이는 클라이언트 측 프로토콜과 서버측 프로토콜을 빗금으로 구분해 기술함(<클라이언트 프로토콜>/<서버 프로토콜>)

## 프로토콜 게이트웨이

서로 다른 형식의 웹 애플리케이션이 통신하는 데 사용

게이트웨이에 프록시처럼 HTTP 트래픽을 바로 보낼 수 있음
브라우저에 명시적으로 게이트웨이를 설정해 트래픽이 게이트웨이를 거처가게 할 수도 있음
게이트웨이를 리버스 프록시로 설정할 수도 있음

- HTTP/*: 서버 측 웹 게이트웨이
    - 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환
- HTTP/HTTPS: 서버 측 보안 게이트웨이
    - 기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보화와 보안 제공
    - 자동으로 사용자의 모든 세션을 암호화
- HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이(보안 가속기)
    - 웹 서버 앞단에 위치하고 보이지 않는 '인터셉트 게이트웨이'나 '리버스 프록시' 역할
    - 보안 HTTPS 트래픽을 받아서 복호화하고 웹 서버로 보낼 일반 HTTP 요청을 만듦
    - 보안 트래픽을 복호화하는 암호화 하드웨어 내장해서 원서버의 부하 감소하기도 함
    - 게이트웨이와 암호화지 않은 트래픽 전송하므로 둘 사이의 네트워크가 안전한지 확인 후 사용해야 함

## 리소스 게이트웨이

일반적인 형태는 애플리케이션 서버 - 목적지 서버와 게이트웨이를 한 개의 서버로 결합함
HTTP로 클라이언트와 통신, 서버 측에 있는 애플리케이션 프로그램(CGI 등)에 연결

- 공용 게이트웨이 인터페이스(CGI)
    - 최초의 서버 확장
    - Perl, TCl, C, 다양한 셸 언어 등으로 구현 가능
    - CGI가 내부에서 어떤 처리를 하는지 사용제에게 보이지 않음
    - 거의 모든 리소스 형식과 서버의 접점에 있으면서 필요에 따라 어떤 변형이든 처리해내는 단순한 기능 제공
    - but, 모든 요청마다 새로운 프로세스를 만드는 데 따른 부하가 크고, 서버 장비에 부담을 줌 ->  Fast CGI 등장
    - Fast CGI는 데몬으로 동작해서 성능 저하 문제를 해결
- 서버 확장 API
    - 서버 동작 변경 및 처리능력 극대화 위해 확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든것으로 교체할 수 있게 함
    - 유명한 서버 대부분은 개발자에게 확장 API를 한 개 이상 제공
    - 이런 확장은 서버 자체 아키텍처에 의존 -> 서버마다 동작 변경 및 다른 리소스에 대한 맞춤 인터페이스를 제공하는데 쓸 수 있는 API 가짐
    - ex. FPSE(FrontPage Server Extension)

## 애플리케이션 인터페이스와 웹서비스

HTTP는 애플리케이션을 연결하는 도구로 활용할 수 있음
데이터 교환 시 두 애플리케이션 사이에서 프로토콜 인터페이스를 맞추는 일이 까다로움
인터넷 커뮤니티는 각 웹 애플리케이션이 서로 통신하 데 사용할 표준과 프로토콜 집합을 개발함
웹 서비스: 원래는 독립형 웹 애플리케이션(빌딩 블록)을 의미했지만, 그냥 웹 앱을 의미하게 됨
웹서비스는 HTTP 같은 표준 웹 기술 위에서 개발함
웹 서비스는 SOAP를 통해 XML을 사용하여 정보를 교환
XML: 데이터를 담는 데이터를 생성하고 해석하는 방식을 제공함
SOAP(Simple Object Access Protocol): HTTP 메시지에 XML을 담는 방식에 대한 표준

## 터널

HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송하는데 사용(웹 터널)

- CONNECT 메서드로 HTTP 터널 커넥션 맺기
    - CONNECT 메서드는 게이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버간에 오는 데이터를 무조건 전달하기를 요청함
        1. 클라이언트가 CONNECT 메서드로 게이트웨이에 TCP 커넥션을 위한 터널 연결 요청
        2. TCP 커넥션 맺어지면 클라이언트에 HTTP 200 Connection Established 응답 전송
        3. 터널 연결. HTTP 터널과 서버로부터 전송된 모든 데이터들이 TCP 커넥션으로 바로 전달.

    - CONNECT 요청
        - ```
          CONNECT home.netscape.com:443 HTTP/1.0
          User-agent: Mozilla/4.0
          ```
    - CONNECT 응답
        - ```
          HTTP/1.0 200 Connection Established
          Proxy-agent: Netscape-Proxy/1.1
          ```
        - Content-Type 헤더 포함 필요 없음
- 데이터 터널링, 시간, 커넥션 관리
    - 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없고 패킷 순서나 흐름을 추정 불가
    - 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송
    - 요청 후에 터널 통해 데이터 전송 클라이언트는 데이터를 다시 보낼 준비가 되어 있어야 함
    - 커넥션이 끊어지면, 그 끊어진 곳으로부터 온 데이터는 반대편으로 전달됨
    - 그 다음 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프록시에 의해 끊어질 것
    - 커넥션이 끊긴 한 쪽에 아직 전송하지 않은 데이터는 버려짐
- SSL 터널링
    - 웹 터널은 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발됨
    - 강력한 보안을 위해 모든 트래픽이 패킷을 필터링하는 라우터와 프록시를 지나도록 하면, 낡은 방식의 프록시는 암호화된 SSL은 처리 불가
    - SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있음
    - SSL 트래픽이 기존 프록시 방화벽을 통과할 수 있도록 HTTP에 터널링 기능이 추가됨
    - 이 터널링 기능은 HTTP 메시지에 암호화된 raw 데이터를 담고 일반 HTTP 채널을 통해 데이터 전송
    - 터널은 HTTP가 아닌 트래픽이 포트를 제한하는 방화벽을 통과할 수 있게 해줌
    - but, 악의적인 트래픽이 사내로 유입되는 경로가 될 수 있음
- SSL 터널링 vs. HTTP/HTTPS 게이트웨이
    - 원격 HTTPS 서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행
    - 응답은 프록시가 받아서 복호화하고 난 후에 HTTP를 통해 클라이언트로 전송
    - 단점
        - 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 HTTP 커넥션이 맺어짐
        - 프록시가 인증을 담당하고 있어 원격 서버에 SSL 클라이언트 인증(X509 인증서 기반 인증) 불가
        - 게이트웨이가 SSL 완벽히 지원해야 함
    - 이 상황에서 SSL 터널링 사용하면 프록시에 SSL 구현할 필요 없음
    - 프록시 서버가 트랜잭션의 보안에 관여하지 않고 암호회된 데이터를 그대로 터널링만 함
- 터널 보안 고려 사항
    - 터널 게이트웨이는 프로토콜이 터널을 올바른 용도로 사용하는지 검증 불가
    - 터널 오용 최소화 위해 443 등 특정 포트만을 터널링 허용해야 함

## 릴레이

일종의 단순한 HTTP 프록시. 한번에 한 개의 홉 데이터를 전달

- HTTP 명세 완전히 준수하지는 않음
- 커넥션을 맺고 바이트를 맹목적으로 전달함
- 단순 필터링, 진단, 컨텐츠 변환 시 유용
- but, 잠재적으로 심각한 상호 운용 문제 있음 -> 주의 필요
- 단순 맹목적 릴레이 구현은 릴레이가 Connection 헤더를 제대로 처리 못해 keep-alive 커넥션이 행에 걸릴 수 있음
- 이런 위험을 방지하기 위해 릴레이를 똑똑하게 만들면 되지만, 프록시의 단순함 이면에 상호 운용성 문제 발생 가능성
- 특정 목적 위해 단순한 HTTP 릴레이 구축시 신중한 고민 필요(HTTP 제대로 준수하는 프록시 사용 필요)

